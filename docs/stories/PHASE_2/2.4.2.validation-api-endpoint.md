# Story 2.4.2: Validation API Endpoint

## Status
Draft

## Story
**As a** developer,
**I want to** validate entities via REST API,
**so that** I can check data quality before publishing or after enrichment.

## Acceptance Criteria
1. `POST /entities/validate` endpoint accepts single or batch entities
2. Return validation result with errors and warnings
3. Support validation level parameter (strict/lenient)
4. Integrate validation with entity creation (optional strict mode)
5. Return HTTP 200 even for invalid entities (errors in response body)
6. Support JSON-LD input format
7. Log validation requests for monitoring

## Tasks / Subtasks
- [ ] Create validation endpoint (AC: 1, 2, 6)
  - [ ] Define request/response Pydantic models
  - [ ] Accept list of entities (max 100)
  - [ ] Return structured validation results
- [ ] Add validation level support (AC: 3)
  - [ ] Accept level query parameter
  - [ ] Default to lenient
  - [ ] Document level differences
- [ ] Return appropriate response (AC: 5)
  - [ ] Always return HTTP 200
  - [ ] Include valid/invalid counts
  - [ ] Include detailed errors per entity
- [ ] Integrate with entity creation (AC: 4)
  - [ ] Add validateOnCreate option to EntityService
  - [ ] Reject invalid entities in strict mode
  - [ ] Return validation errors in response
- [ ] Add logging (AC: 7)
  - [ ] Log request count
  - [ ] Log validation result summary
  - [ ] Track validation success rate
- [ ] Write API tests
  - [ ] Test single entity validation
  - [ ] Test batch validation
  - [ ] Test level parameter
  - [ ] Test integration with creation

## Dev Notes

### Relevant Source Tree
```
reasoning-service/
├── app/
│   ├── api/
│   │   └── validation.py       # NEW - Create this file
│   └── services/
│       └── schema_validator.py # Story 2.4.1
└── tests/
    └── test_validation_api.py  # NEW

backend/src/main/java/org/newsanalyzer/
├── service/
│   └── EntityService.java      # MODIFY - Add validation integration
└── controller/
    └── ValidationController.java # NEW - Java validation endpoint
```

### Python API Implementation

```python
# app/api/validation.py

from fastapi import APIRouter, Query
from pydantic import BaseModel, Field
from typing import List, Optional
from enum import Enum
import logging

from app.services.schema_validator import (
    get_validator,
    ValidationLevel,
    ValidationResult
)

router = APIRouter(prefix="/entities", tags=["Validation"])
logger = logging.getLogger("validation_api")

class EntityInput(BaseModel):
    """Entity to validate (JSON-LD format)"""
    context: Optional[str] = Field(None, alias="@context")
    type: str = Field(..., alias="@type")
    id: Optional[str] = Field(None, alias="@id")
    name: str
    # Allow any additional properties
    class Config:
        extra = "allow"

class ValidationRequest(BaseModel):
    """Request for entity validation"""
    entities: List[dict] = Field(
        ...,
        max_items=100,
        description="List of entities to validate (JSON-LD format)"
    )
    level: ValidationLevel = Field(
        ValidationLevel.LENIENT,
        description="Validation level: strict or lenient"
    )

class ValidationErrorResponse(BaseModel):
    """Individual validation error"""
    property: str = Field(..., alias="property_path")
    message: str
    severity: str
    expected: Optional[str] = None
    actual: Optional[str] = None

class EntityValidationResult(BaseModel):
    """Validation result for single entity"""
    entity_id: Optional[str]
    entity_name: Optional[str]
    valid: bool
    error_count: int
    warning_count: int
    errors: List[ValidationErrorResponse]
    warnings: List[ValidationErrorResponse]

class ValidationResponse(BaseModel):
    """Response for validation request"""
    valid: bool
    total_entities: int
    valid_count: int
    invalid_count: int
    total_errors: int
    total_warnings: int
    results: List[EntityValidationResult]

@router.post("/validate", response_model=ValidationResponse)
async def validate_entities(
    request: ValidationRequest,
    level: Optional[ValidationLevel] = Query(
        None,
        description="Override validation level from request body"
    )
):
    """
    Validate entities against Schema.org vocabulary.

    **Validation Levels:**
    - `lenient` (default): Checks @context, @type, and required properties only
    - `strict`: All checks plus expected properties and nested objects

    **Returns:**
    - HTTP 200 always (check `valid` field for overall result)
    - Detailed errors and warnings per entity

    **Example Request:**
    ```json
    {
      "entities": [
        {
          "@context": "https://schema.org",
          "@type": "Person",
          "name": "Elizabeth Warren"
        }
      ],
      "level": "lenient"
    }
    ```
    """
    # Use query param level if provided, otherwise use request body level
    validation_level = level or request.level

    logger.info(
        f"Validation request: {len(request.entities)} entities, level={validation_level}"
    )

    validator = get_validator()
    results = validator.validate_batch(request.entities, validation_level)

    # Build response
    entity_results = []
    total_errors = 0
    total_warnings = 0

    for i, result in enumerate(results):
        entity = request.entities[i]
        entity_result = EntityValidationResult(
            entity_id=result.entity_id or entity.get("@id"),
            entity_name=entity.get("name"),
            valid=result.valid,
            error_count=len(result.errors),
            warning_count=len(result.warnings),
            errors=[
                ValidationErrorResponse(
                    property_path=e.property_path,
                    message=e.message,
                    severity=e.severity.value,
                    expected=e.expected,
                    actual=e.actual
                )
                for e in result.errors
            ],
            warnings=[
                ValidationErrorResponse(
                    property_path=e.property_path,
                    message=e.message,
                    severity=e.severity.value,
                    expected=e.expected,
                    actual=e.actual
                )
                for e in result.warnings
            ]
        )
        entity_results.append(entity_result)
        total_errors += len(result.errors)
        total_warnings += len(result.warnings)

    valid_count = sum(1 for r in results if r.valid)
    invalid_count = len(results) - valid_count

    logger.info(
        f"Validation complete: {valid_count}/{len(results)} valid, "
        f"{total_errors} errors, {total_warnings} warnings"
    )

    return ValidationResponse(
        valid=invalid_count == 0,
        total_entities=len(results),
        valid_count=valid_count,
        invalid_count=invalid_count,
        total_errors=total_errors,
        total_warnings=total_warnings,
        results=entity_results
    )


@router.post("/validate/single")
async def validate_single_entity(
    entity: dict,
    level: ValidationLevel = Query(ValidationLevel.LENIENT)
):
    """
    Validate a single entity.

    Convenience endpoint for validating one entity without wrapping in array.
    """
    validator = get_validator()
    result = validator.validate(entity, level)

    return EntityValidationResult(
        entity_id=result.entity_id or entity.get("@id"),
        entity_name=entity.get("name"),
        valid=result.valid,
        error_count=len(result.errors),
        warning_count=len(result.warnings),
        errors=[
            ValidationErrorResponse(
                property_path=e.property_path,
                message=e.message,
                severity=e.severity.value,
                expected=e.expected,
                actual=e.actual
            )
            for e in result.errors
        ],
        warnings=[
            ValidationErrorResponse(
                property_path=e.property_path,
                message=e.message,
                severity=e.severity.value,
                expected=e.expected,
                actual=e.actual
            )
            for e in result.warnings
        ]
    )
```

### Java Validation Integration

```java
// Modify EntityService.java

/**
 * Create entity with optional validation.
 */
@Transactional
public Entity createEntity(CreateEntityRequest request, boolean validateStrict) {
    // Build JSON-LD for validation
    if (validateStrict) {
        Map<String, Object> jsonLd = buildJsonLdForValidation(request);
        ValidationResult result = validateEntity(jsonLd);

        if (!result.isValid()) {
            throw new EntityValidationException(
                "Entity failed Schema.org validation",
                result.getErrors()
            );
        }
    }

    // Proceed with creation
    Entity entity = new Entity();
    // ... existing creation logic ...

    return entityRepository.save(entity);
}

/**
 * Call Python validation service.
 */
private ValidationResult validateEntity(Map<String, Object> jsonLd) {
    try {
        return webClient.post()
            .uri(validationServiceUrl + "/entities/validate/single")
            .bodyValue(jsonLd)
            .retrieve()
            .bodyToMono(ValidationResult.class)
            .block(Duration.ofSeconds(5));
    } catch (Exception e) {
        log.warn("Validation service unavailable, skipping validation", e);
        return ValidationResult.valid(); // Fail open
    }
}
```

### Java Validation Controller

```java
// ValidationController.java

package org.newsanalyzer.controller;

import org.springframework.web.bind.annotation.*;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;

@RestController
@RequestMapping("/api/entities")
@Tag(name = "Validation", description = "Schema.org validation")
public class ValidationController {

    private final WebClient webClient;

    @Value("${validation.service.url:http://localhost:8000}")
    private String validationServiceUrl;

    @PostMapping("/validate")
    @Operation(summary = "Validate entities against Schema.org")
    public ResponseEntity<Map<String, Object>> validateEntities(
            @RequestBody List<Map<String, Object>> entities,
            @RequestParam(defaultValue = "lenient") String level
    ) {
        // Forward to Python validation service
        Map<String, Object> request = Map.of(
            "entities", entities,
            "level", level
        );

        return webClient.post()
            .uri(validationServiceUrl + "/entities/validate")
            .bodyValue(request)
            .retrieve()
            .toEntity(new ParameterizedTypeReference<Map<String, Object>>() {})
            .block();
    }

    @GetMapping("/{id}/validate")
    @Operation(summary = "Validate existing entity")
    public ResponseEntity<Map<String, Object>> validateExistingEntity(
            @PathVariable UUID id,
            @RequestParam(defaultValue = "lenient") String level
    ) {
        Entity entity = entityService.findById(id);
        Map<String, Object> jsonLd = jsonLdService.generateJsonLd(entity);

        return webClient.post()
            .uri(validationServiceUrl + "/entities/validate/single")
            .queryParam("level", level)
            .bodyValue(jsonLd)
            .retrieve()
            .toEntity(new ParameterizedTypeReference<Map<String, Object>>() {})
            .block();
    }
}
```

### Example API Response

```json
{
  "valid": false,
  "total_entities": 2,
  "valid_count": 1,
  "invalid_count": 1,
  "total_errors": 2,
  "total_warnings": 1,
  "results": [
    {
      "entity_id": "550e8400-e29b-41d4-a716-446655440001",
      "entity_name": "Environmental Protection Agency",
      "valid": true,
      "error_count": 0,
      "warning_count": 0,
      "errors": [],
      "warnings": []
    },
    {
      "entity_id": null,
      "entity_name": null,
      "valid": false,
      "error_count": 2,
      "warning_count": 1,
      "errors": [
        {
          "property": "@type",
          "message": "Invalid Schema.org type: InvalidType",
          "severity": "error",
          "expected": "Person, Organization, ...",
          "actual": "InvalidType"
        },
        {
          "property": "name",
          "message": "Missing required property: name",
          "severity": "error",
          "expected": null,
          "actual": null
        }
      ],
      "warnings": [
        {
          "property": "url",
          "message": "Missing expected property: url",
          "severity": "warning",
          "expected": null,
          "actual": null
        }
      ]
    }
  ]
}
```

## Testing

### Test File Location
`reasoning-service/tests/test_validation_api.py`

### Testing Standards
- Use pytest with pytest-asyncio
- Use FastAPI TestClient
- Test all endpoints
- Minimum 90% coverage

### Test Cases
```python
@pytest.mark.asyncio
async def test_validate_valid_entity():
    """Test valid entity returns valid=true"""

@pytest.mark.asyncio
async def test_validate_invalid_entity():
    """Test invalid entity returns errors"""

@pytest.mark.asyncio
async def test_validate_batch():
    """Test batch validation of multiple entities"""

@pytest.mark.asyncio
async def test_validate_level_strict():
    """Test strict level includes expected property warnings"""

@pytest.mark.asyncio
async def test_validate_level_lenient():
    """Test lenient level ignores expected properties"""

@pytest.mark.asyncio
async def test_validate_single_convenience():
    """Test /validate/single endpoint"""

@pytest.mark.asyncio
async def test_validate_max_entities():
    """Test max 100 entities per request"""

@pytest.mark.asyncio
async def test_validate_returns_200_for_invalid():
    """Test HTTP 200 returned even for invalid entities"""

@pytest.mark.asyncio
async def test_validation_logging():
    """Test validation requests are logged"""
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-25 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_
