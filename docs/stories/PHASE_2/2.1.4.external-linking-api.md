# Story 2.1.4: External Linking Service API

## Status
Draft

## Story
**As a** developer,
**I want to** call a REST API to link entities to external knowledge bases,
**so that** I can integrate entity linking into the processing pipeline.

## Acceptance Criteria
1. Implement `POST /entities/link` endpoint in Python service
2. Accept single entity or batch of entities (up to 100)
3. Return linked entity with external IDs (wikidata_id, dbpedia_uri)
4. Support async processing for large batches
5. Return linking status and confidence for each entity
6. Log all linking attempts for debugging
7. Support source selection (wikidata, dbpedia, or both)
8. Return candidate list for manual review when confidence < 0.7

## Tasks / Subtasks
- [ ] Create EntityLinker orchestrator class (AC: 1, 3, 7)
  - [ ] Coordinate WikidataClient and DBpediaClient
  - [ ] Implement fallback logic (Wikidata first, then DBpedia)
  - [ ] Call DisambiguationService to select best match
  - [ ] Return standardized LinkResult object
- [ ] Update /entities/link endpoint (AC: 1, 2, 5)
  - [ ] Replace existing stub implementation
  - [ ] Define request/response Pydantic models
  - [ ] Handle single and batch requests
  - [ ] Return detailed linking results
- [ ] Implement batch processing (AC: 2, 4)
  - [ ] Process entities in parallel (asyncio)
  - [ ] Respect rate limits across batch
  - [ ] Return partial results if some fail
- [ ] Add candidate response for low confidence (AC: 8)
  - [ ] Include top 5 candidates when confidence < 0.7
  - [ ] Mark entity as "needs_review"
- [ ] Add comprehensive logging (AC: 6)
  - [ ] Log request details
  - [ ] Log external API calls
  - [ ] Log disambiguation decisions
  - [ ] Log final results
- [ ] Write integration tests
  - [ ] Test single entity linking
  - [ ] Test batch linking
  - [ ] Test source selection
  - [ ] Test low-confidence handling

## Dev Notes

### Relevant Source Tree
```
reasoning-service/
├── app/
│   ├── services/
│   │   ├── entity_linker.py    # NEW - Create orchestrator
│   │   ├── wikidata_client.py  # Story 2.1.1
│   │   ├── dbpedia_client.py   # Story 2.1.2
│   │   └── disambiguation.py   # Story 2.1.3
│   └── api/
│       └── entities.py         # MODIFY - Update /link endpoint
└── tests/
    └── test_entity_linker.py   # NEW - Integration tests
```

### Existing Stub Endpoint
The endpoint already exists in `entities.py` (lines 111-122):
```python
@router.post("/link")
async def link_entities(entities: List[Dict[str, Any]]):
    """Link extracted entities to Schema.org types and external knowledge bases."""
    # TODO: Implement entity linking
    return {"status": "not_implemented"}
```

### Request/Response Models

```python
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
from enum import Enum

class LinkingSource(str, Enum):
    WIKIDATA = "wikidata"
    DBPEDIA = "dbpedia"
    BOTH = "both"

class EntityLinkRequest(BaseModel):
    text: str = Field(..., description="Entity text to link")
    entity_type: str = Field(..., description="Entity type (person, government_org, etc.)")
    context: Optional[str] = Field(None, description="Surrounding text for disambiguation")

class LinkingOptions(BaseModel):
    sources: LinkingSource = Field(LinkingSource.BOTH, description="Which KBs to query")
    min_confidence: float = Field(0.7, description="Minimum confidence for auto-link")
    max_candidates: int = Field(5, description="Max candidates to return")

class LinkRequest(BaseModel):
    entities: List[EntityLinkRequest] = Field(..., max_items=100)
    options: LinkingOptions = Field(default_factory=LinkingOptions)

class Candidate(BaseModel):
    id: str  # QID or DBpedia URI
    label: str
    description: Optional[str]
    source: str  # "wikidata" or "dbpedia"
    confidence: float

class LinkedEntity(BaseModel):
    text: str
    entity_type: str
    wikidata_id: Optional[str] = None
    wikidata_url: Optional[str] = None
    dbpedia_uri: Optional[str] = None
    linking_confidence: float
    linking_source: Optional[str] = None
    needs_review: bool = False
    candidates: List[Candidate] = Field(default_factory=list)

class LinkingStats(BaseModel):
    total: int
    linked: int
    needs_review: int
    failed: int

class LinkResponse(BaseModel):
    linked_entities: List[LinkedEntity]
    statistics: LinkingStats
```

### EntityLinker Orchestrator

```python
class EntityLinker:
    def __init__(self):
        self.wikidata = get_wikidata_client()
        self.dbpedia = get_dbpedia_client()
        self.disambiguator = DisambiguationService()

    async def link_entity(
        self,
        text: str,
        entity_type: str,
        context: Optional[str] = None,
        sources: LinkingSource = LinkingSource.BOTH
    ) -> LinkedEntity:
        candidates = []

        # Query Wikidata first
        if sources in [LinkingSource.WIKIDATA, LinkingSource.BOTH]:
            wikidata_candidates = await self.wikidata.search(text, entity_type)
            candidates.extend(wikidata_candidates)

        # Query DBpedia as fallback or if requested
        if sources == LinkingSource.DBPEDIA or (
            sources == LinkingSource.BOTH and len(candidates) == 0
        ):
            dbpedia_candidates = await self.dbpedia.search(text, entity_type)
            candidates.extend(dbpedia_candidates)

        if not candidates:
            return LinkedEntity(
                text=text,
                entity_type=entity_type,
                linking_confidence=0.0,
                needs_review=True
            )

        # Disambiguate
        result = self.disambiguator.disambiguate(
            entity_text=text,
            entity_type=entity_type,
            candidates=candidates,
            context=context
        )

        return LinkedEntity(
            text=text,
            entity_type=entity_type,
            wikidata_id=result.match.qid if result.match and result.match.source == "wikidata" else None,
            wikidata_url=f"https://www.wikidata.org/wiki/{result.match.qid}" if result.match and result.match.source == "wikidata" else None,
            dbpedia_uri=result.match.uri if result.match and result.match.source == "dbpedia" else None,
            linking_confidence=result.confidence,
            linking_source=result.match.source if result.match else None,
            needs_review=result.needs_review,
            candidates=result.all_candidates[:5] if result.needs_review else []
        )

    async def link_batch(
        self,
        entities: List[EntityLinkRequest],
        options: LinkingOptions
    ) -> List[LinkedEntity]:
        tasks = [
            self.link_entity(
                text=e.text,
                entity_type=e.entity_type,
                context=e.context,
                sources=options.sources
            )
            for e in entities
        ]
        return await asyncio.gather(*tasks, return_exceptions=True)
```

### Singleton Pattern

```python
_linker_instance = None

def get_entity_linker() -> EntityLinker:
    global _linker_instance
    if _linker_instance is None:
        _linker_instance = EntityLinker()
    return _linker_instance
```

### Updated Endpoint

```python
@router.post("/link", response_model=LinkResponse)
async def link_entities(request: LinkRequest):
    """
    Link extracted entities to external knowledge bases (Wikidata, DBpedia).

    Returns linked entities with external IDs and confidence scores.
    Entities with confidence < 0.7 are flagged for manual review.
    """
    linker = get_entity_linker()

    results = await linker.link_batch(request.entities, request.options)

    # Calculate statistics
    linked = [r for r in results if not isinstance(r, Exception) and r.linking_confidence >= 0.7]
    needs_review = [r for r in results if not isinstance(r, Exception) and r.needs_review]
    failed = [r for r in results if isinstance(r, Exception)]

    return LinkResponse(
        linked_entities=[r for r in results if not isinstance(r, Exception)],
        statistics=LinkingStats(
            total=len(request.entities),
            linked=len(linked),
            needs_review=len(needs_review),
            failed=len(failed)
        )
    )
```

## Testing

### Test File Location
`reasoning-service/tests/test_entity_linker.py`

### Testing Standards
- Use pytest framework with pytest-asyncio
- Mock WikidataClient and DBpediaClient
- Test end-to-end flow
- Minimum 90% coverage

### Test Cases
```python
@pytest.mark.asyncio
async def test_link_single_entity_success():
    """Test linking single entity returns external IDs"""

@pytest.mark.asyncio
async def test_link_batch_entities():
    """Test batch linking processes all entities"""

@pytest.mark.asyncio
async def test_link_with_wikidata_only():
    """Test source=wikidata only queries Wikidata"""

@pytest.mark.asyncio
async def test_link_with_dbpedia_fallback():
    """Test DBpedia used when Wikidata returns nothing"""

@pytest.mark.asyncio
async def test_low_confidence_returns_candidates():
    """Test needs_review entities include candidates"""

@pytest.mark.asyncio
async def test_batch_partial_failure():
    """Test batch returns successful results even if some fail"""

@pytest.mark.asyncio
async def test_statistics_accurate():
    """Test response statistics are accurate"""
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-25 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_
