# Story 2.2.2: Property Merge Strategy

## Status
Draft

## Story
**As a** system,
**I want to** merge external properties with existing entity properties using defined rules,
**so that** external data enriches entities without overwriting valuable local data.

## Acceptance Criteria
1. Define merge priority: local properties take precedence over external
2. Append external properties that don't exist locally
3. Track property provenance (source: "local", "wikidata", "dbpedia")
4. Support conflict resolution configuration
5. Log all property changes for audit trail
6. Handle array properties by merging and deduplicating
7. Return merge report with changes made

## Tasks / Subtasks
- [ ] Create PropertyMerger class (AC: 1, 2)
  - [ ] Implement priority-based merge logic
  - [ ] Handle property existence checks
  - [ ] Preserve original values
- [ ] Implement provenance tracking (AC: 3)
  - [ ] Create provenance metadata structure
  - [ ] Tag each property with source
  - [ ] Store merge timestamp
- [ ] Add conflict resolution (AC: 4)
  - [ ] Define conflict scenarios
  - [ ] Support configurable resolution strategies
  - [ ] Flag unresolved conflicts
- [ ] Handle array merging (AC: 6)
  - [ ] Merge array properties (alternateName, sameAs)
  - [ ] Deduplicate array values
  - [ ] Preserve order (local first)
- [ ] Implement audit logging (AC: 5)
  - [ ] Log before/after state
  - [ ] Log merge decisions
  - [ ] Log conflicts and resolutions
- [ ] Create merge report (AC: 7)
  - [ ] List properties added
  - [ ] List properties skipped (local existed)
  - [ ] List conflicts
- [ ] Write unit tests
  - [ ] Test local priority
  - [ ] Test external property addition
  - [ ] Test array merging
  - [ ] Test conflict detection

## Dev Notes

### Relevant Source Tree
```
reasoning-service/
├── app/
│   ├── services/
│   │   ├── property_merger.py      # NEW - Create this file
│   │   ├── property_extractor.py   # Story 2.2.1 - provides external props
│   │   └── enrichment_pipeline.py  # Story 2.2.3 - will use this
└── tests/
    └── test_property_merger.py     # NEW - Create this file
```

### Merge Rules

```
Rule 1: LOCAL PRIORITY
  - If local property exists → Keep local (don't overwrite)
  - Rationale: Local data may be manually curated or more accurate

Rule 2: EXTERNAL ADDITION
  - If property only exists in external → Add with source tag
  - Rationale: Enrich with new information

Rule 3: CONFLICT HANDLING
  - If both exist with different values → Keep both, mark conflict
  - Rationale: Let human decide which is correct

Rule 4: ARRAY MERGE
  - Arrays (alternateName, sameAs) → Merge and dedupe
  - Local values first, then external
  - Rationale: Accumulate alternative names/identifiers
```

### PropertyMerger Class

```python
from typing import Dict, Any, List, Optional
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum

class ConflictResolution(str, Enum):
    KEEP_LOCAL = "keep_local"
    KEEP_EXTERNAL = "keep_external"
    KEEP_BOTH = "keep_both"
    FLAG_FOR_REVIEW = "flag_for_review"

@dataclass
class PropertyChange:
    property_name: str
    action: str  # "added", "skipped", "merged", "conflict"
    old_value: Any = None
    new_value: Any = None
    source: str = None

@dataclass
class MergeReport:
    entity_id: str
    properties_added: List[str] = field(default_factory=list)
    properties_skipped: List[str] = field(default_factory=list)
    properties_merged: List[str] = field(default_factory=list)
    conflicts: List[PropertyChange] = field(default_factory=list)
    changes: List[PropertyChange] = field(default_factory=list)
    merged_at: datetime = None

class PropertyMerger:
    # Properties that should be merged as arrays
    ARRAY_PROPERTIES = {
        "alternateName",
        "sameAs",
        "additionalType",
        "identifier",
    }

    def __init__(self, conflict_resolution: ConflictResolution = ConflictResolution.KEEP_LOCAL):
        self.conflict_resolution = conflict_resolution

    def merge(
        self,
        entity_id: str,
        local_properties: Dict[str, Any],
        external_properties: Dict[str, Any],
        external_source: str = "wikidata"
    ) -> tuple[Dict[str, Any], Dict[str, str], MergeReport]:
        """
        Merge external properties into local properties.

        Returns:
            - merged_properties: Final merged property dict
            - provenance: Dict mapping property name to source
            - report: MergeReport with details of changes
        """
        merged = dict(local_properties)  # Start with local
        provenance = {}
        report = MergeReport(entity_id=entity_id, merged_at=datetime.utcnow())

        # Track provenance for existing local properties
        for key in local_properties:
            provenance[key] = "local"

        # Process each external property
        for key, ext_value in external_properties.items():
            if key in self.ARRAY_PROPERTIES:
                # Array merge
                merged[key], prov = self._merge_array(
                    local_properties.get(key, []),
                    ext_value,
                    external_source
                )
                provenance[key] = prov
                report.properties_merged.append(key)
                report.changes.append(PropertyChange(
                    property_name=key,
                    action="merged",
                    old_value=local_properties.get(key),
                    new_value=merged[key],
                    source=prov
                ))

            elif key not in local_properties:
                # New property - add from external
                merged[key] = ext_value
                provenance[key] = external_source
                report.properties_added.append(key)
                report.changes.append(PropertyChange(
                    property_name=key,
                    action="added",
                    new_value=ext_value,
                    source=external_source
                ))

            elif local_properties[key] != ext_value:
                # Conflict - different values
                conflict = PropertyChange(
                    property_name=key,
                    action="conflict",
                    old_value=local_properties[key],
                    new_value=ext_value,
                    source=external_source
                )
                report.conflicts.append(conflict)

                # Resolve based on strategy
                if self.conflict_resolution == ConflictResolution.KEEP_LOCAL:
                    report.properties_skipped.append(key)
                elif self.conflict_resolution == ConflictResolution.KEEP_EXTERNAL:
                    merged[key] = ext_value
                    provenance[key] = external_source
                elif self.conflict_resolution == ConflictResolution.KEEP_BOTH:
                    # Store as conflict marker
                    merged[f"{key}_conflict"] = {
                        "local": local_properties[key],
                        "external": ext_value,
                        "external_source": external_source
                    }
                # FLAG_FOR_REVIEW: keep local, conflict logged
            else:
                # Same value - skip
                report.properties_skipped.append(key)

        return merged, provenance, report

    def _merge_array(
        self,
        local_array: List,
        external_array: Any,
        external_source: str
    ) -> tuple[List, str]:
        """Merge array properties, deduplicating values."""
        # Ensure both are lists
        if not isinstance(local_array, list):
            local_array = [local_array] if local_array else []
        if not isinstance(external_array, list):
            external_array = [external_array] if external_array else []

        # Merge with deduplication (local first)
        seen = set()
        merged = []

        for item in local_array:
            normalized = str(item).lower().strip()
            if normalized not in seen:
                seen.add(normalized)
                merged.append(item)

        for item in external_array:
            normalized = str(item).lower().strip()
            if normalized not in seen:
                seen.add(normalized)
                merged.append(item)

        # Provenance: "local+external" if both contributed
        if local_array and external_array:
            provenance = f"local+{external_source}"
        elif external_array:
            provenance = external_source
        else:
            provenance = "local"

        return merged, provenance
```

### Provenance Structure

The provenance dict is stored alongside properties in the entity:

```python
# Entity.properties JSONB structure after merge:
{
    "name": "Environmental Protection Agency",
    "acronym": "EPA",
    "foundingDate": "1970-12-02",
    "url": "https://www.epa.gov",
    "alternateName": ["EPA", "US EPA", "Environmental Protection Agency"],
    "sameAs": [
        "https://www.wikidata.org/wiki/Q217173",
        "http://dbpedia.org/resource/United_States_Environmental_Protection_Agency"
    ],

    # Provenance metadata
    "_provenance": {
        "name": "local",
        "acronym": "local",
        "foundingDate": "wikidata",
        "url": "wikidata",
        "alternateName": "local+wikidata",
        "sameAs": "wikidata"
    },
    "_merged_at": "2025-11-25T10:30:00Z"
}
```

### Audit Log Format

```python
import logging

logger = logging.getLogger("property_merger")

def log_merge(report: MergeReport):
    logger.info(
        "Property merge completed",
        extra={
            "entity_id": report.entity_id,
            "properties_added": report.properties_added,
            "properties_skipped": report.properties_skipped,
            "conflicts": len(report.conflicts),
            "merged_at": report.merged_at.isoformat()
        }
    )

    for conflict in report.conflicts:
        logger.warning(
            f"Property conflict: {conflict.property_name}",
            extra={
                "entity_id": report.entity_id,
                "property": conflict.property_name,
                "local_value": conflict.old_value,
                "external_value": conflict.new_value,
                "external_source": conflict.source
            }
        )
```

## Testing

### Test File Location
`reasoning-service/tests/test_property_merger.py`

### Testing Standards
- Use pytest framework
- Test all merge scenarios
- Minimum 95% coverage (critical data path)

### Test Cases
```python
def test_local_property_takes_priority():
    """Test local property not overwritten by external"""

def test_external_property_added():
    """Test new external property added to entity"""

def test_array_properties_merged():
    """Test alternateName arrays merged and deduped"""

def test_array_local_first():
    """Test local array values appear before external"""

def test_conflict_detected():
    """Test different values flagged as conflict"""

def test_conflict_resolution_keep_local():
    """Test KEEP_LOCAL resolution keeps local value"""

def test_conflict_resolution_keep_external():
    """Test KEEP_EXTERNAL resolution uses external value"""

def test_conflict_resolution_keep_both():
    """Test KEEP_BOTH stores both values"""

def test_provenance_tracking():
    """Test each property tagged with source"""

def test_merge_report_accurate():
    """Test MergeReport contains all changes"""

def test_same_values_skipped():
    """Test identical values don't create conflict"""
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-25 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_
