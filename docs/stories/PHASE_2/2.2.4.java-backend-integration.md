# Story 2.2.4: Java Backend Integration

## Status
Draft

## Story
**As a** developer,
**I want to** trigger enrichment from the Java backend and store results,
**so that** entity creation automatically queues enrichment and results persist in the database.

## Acceptance Criteria
1. Add `enrichmentStatus` and `enrichedAt` fields to Entity model
2. Call Python enrichment API after entity creation (async)
3. Store enrichment results (external IDs, properties) in entity record
4. Support manual re-enrichment via REST API
5. Add enrichment fields to EntityDTO for API responses
6. Create database migration for new fields
7. Handle enrichment service unavailability gracefully

## Tasks / Subtasks
- [ ] Create database migration V5 (AC: 6)
  - [ ] Add enrichment_status column
  - [ ] Add enrichment_error column
  - [ ] Add enrichment_retry_count column
  - [ ] Add enriched_at column
  - [ ] Add index on enrichment_status
- [ ] Update Entity model (AC: 1)
  - [ ] Add EnrichmentStatus enum
  - [ ] Add enrichmentStatus field
  - [ ] Add enrichedAt field
  - [ ] Add enrichmentError field
- [ ] Update EntityDTO (AC: 5)
  - [ ] Add enrichment fields
  - [ ] Add external ID fields (wikidataId, dbpediaUri)
  - [ ] Update toDTO() method
- [ ] Create EnrichmentService (AC: 2, 3)
  - [ ] HTTP client for Python enrichment API
  - [ ] Async enrichment trigger
  - [ ] Result parsing and storage
- [ ] Create EnrichmentController (AC: 4)
  - [ ] POST /api/entities/{id}/enrich endpoint
  - [ ] POST /api/entities/enrich/bulk endpoint
  - [ ] GET /api/entities/{id}/enrichment-status endpoint
- [ ] Handle service unavailability (AC: 7)
  - [ ] Circuit breaker pattern
  - [ ] Graceful degradation
  - [ ] Entity creation succeeds even if enrichment fails
- [ ] Write unit tests
  - [ ] Test entity creation triggers enrichment
  - [ ] Test enrichment results stored
  - [ ] Test manual re-enrichment
  - [ ] Test circuit breaker

## Dev Notes

### Relevant Source Tree
```
backend/src/main/java/org/newsanalyzer/
├── model/
│   ├── Entity.java           # MODIFY - Add enrichment fields
│   └── EnrichmentStatus.java # NEW - Create enum
├── dto/
│   └── EntityDTO.java        # MODIFY - Add enrichment fields
├── service/
│   ├── EntityService.java    # MODIFY - Trigger enrichment
│   └── EnrichmentService.java # NEW - Create service
├── controller/
│   └── EnrichmentController.java # NEW - Create controller
└── config/
    └── EnrichmentConfig.java # NEW - HTTP client config

backend/src/main/resources/db/migration/
└── V5__add_enrichment_fields.sql # NEW - Migration

backend/src/test/java/org/newsanalyzer/
├── service/
│   └── EnrichmentServiceTest.java # NEW
└── controller/
    └── EnrichmentControllerTest.java # NEW
```

### Database Migration V5

```sql
-- V5__add_enrichment_fields.sql

-- Add enrichment tracking columns
ALTER TABLE entities
ADD COLUMN enrichment_status VARCHAR(20) DEFAULT 'PENDING',
ADD COLUMN enrichment_error TEXT,
ADD COLUMN enrichment_retry_count INTEGER DEFAULT 0,
ADD COLUMN enriched_at TIMESTAMP;

-- Index for enrichment queue queries
CREATE INDEX idx_entities_enrichment_status
ON entities(enrichment_status)
WHERE enrichment_status IN ('PENDING', 'LINK_FAILED', 'ENRICH_FAILED');

-- Index for external ID lookup in JSONB properties
CREATE INDEX idx_entities_wikidata_id
ON entities ((properties->>'wikidata_id'))
WHERE properties->>'wikidata_id' IS NOT NULL;

CREATE INDEX idx_entities_dbpedia_uri
ON entities ((properties->>'dbpedia_uri'))
WHERE properties->>'dbpedia_uri' IS NOT NULL;

-- Comments
COMMENT ON COLUMN entities.enrichment_status IS
'Enrichment pipeline status: PENDING, LINKING, ENRICHING, COMPLETE, FAILED';

COMMENT ON COLUMN entities.enriched_at IS
'Timestamp when entity was successfully enriched';
```

### EnrichmentStatus Enum

```java
package org.newsanalyzer.model;

public enum EnrichmentStatus {
    PENDING,      // Awaiting enrichment
    LINKING,      // Currently linking to external KBs
    LINK_FAILED,  // Linking failed, will retry
    ENRICHING,    // Fetching external properties
    ENRICH_FAILED,// Property fetch failed, will retry
    COMPLETE,     // Successfully enriched
    FAILED        // Failed after max retries
}
```

### Entity Model Updates

```java
// Add to Entity.java

/**
 * Current enrichment pipeline status.
 */
@Enumerated(EnumType.STRING)
@Column(name = "enrichment_status", length = 20)
private EnrichmentStatus enrichmentStatus = EnrichmentStatus.PENDING;

/**
 * Timestamp when entity was successfully enriched.
 */
@Column(name = "enriched_at")
private LocalDateTime enrichedAt;

/**
 * Error message if enrichment failed.
 */
@Column(name = "enrichment_error", columnDefinition = "TEXT")
private String enrichmentError;

/**
 * Number of enrichment retry attempts.
 */
@Column(name = "enrichment_retry_count")
private Integer enrichmentRetryCount = 0;

// Convenience methods

public boolean isEnriched() {
    return enrichmentStatus == EnrichmentStatus.COMPLETE;
}

public String getWikidataId() {
    return properties != null ? (String) properties.get("wikidata_id") : null;
}

public String getDbpediaUri() {
    return properties != null ? (String) properties.get("dbpedia_uri") : null;
}
```

### EntityDTO Updates

```java
// Add to EntityDTO.java

private EnrichmentStatus enrichmentStatus;
private LocalDateTime enrichedAt;
private String wikidataId;
private String wikidataUrl;
private String dbpediaUri;
private Float linkingConfidence;

// Update toDTO method
public static EntityDTO toDTO(Entity entity) {
    EntityDTO dto = new EntityDTO();
    // ... existing mappings ...

    dto.setEnrichmentStatus(entity.getEnrichmentStatus());
    dto.setEnrichedAt(entity.getEnrichedAt());

    // Extract external IDs from properties
    if (entity.getProperties() != null) {
        dto.setWikidataId((String) entity.getProperties().get("wikidata_id"));
        dto.setDbpediaUri((String) entity.getProperties().get("dbpedia_uri"));
        dto.setLinkingConfidence(
            entity.getProperties().get("linking_confidence") != null
                ? ((Number) entity.getProperties().get("linking_confidence")).floatValue()
                : null
        );

        if (dto.getWikidataId() != null) {
            dto.setWikidataUrl("https://www.wikidata.org/wiki/" + dto.getWikidataId());
        }
    }

    return dto;
}
```

### EnrichmentService

```java
package org.newsanalyzer.service;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
import reactor.core.publisher.Mono;
import java.time.Duration;

@Service
public class EnrichmentService {

    private final WebClient webClient;
    private final EntityRepository entityRepository;

    @Value("${enrichment.service.url:http://localhost:8000}")
    private String enrichmentServiceUrl;

    public EnrichmentService(EntityRepository entityRepository) {
        this.entityRepository = entityRepository;
        this.webClient = WebClient.builder()
            .baseUrl(enrichmentServiceUrl)
            .build();
    }

    /**
     * Queue entity for enrichment (async, non-blocking).
     */
    @CircuitBreaker(name = "enrichmentService", fallbackMethod = "queueEnrichmentFallback")
    public Mono<Void> queueForEnrichment(UUID entityId) {
        return webClient.post()
            .uri("/enrichment/queue/{id}", entityId)
            .retrieve()
            .bodyToMono(Void.class)
            .timeout(Duration.ofSeconds(5));
    }

    /**
     * Fallback when enrichment service unavailable.
     * Entity remains in PENDING state for later processing.
     */
    public Mono<Void> queueEnrichmentFallback(UUID entityId, Throwable t) {
        log.warn("Enrichment service unavailable, entity {} will be processed later", entityId);
        return Mono.empty();
    }

    /**
     * Manually trigger enrichment for entity.
     */
    public void triggerEnrichment(UUID entityId) {
        Entity entity = entityRepository.findById(entityId)
            .orElseThrow(() -> new EntityNotFoundException(entityId));

        // Reset status
        entity.setEnrichmentStatus(EnrichmentStatus.PENDING);
        entity.setEnrichmentRetryCount(0);
        entity.setEnrichmentError(null);
        entityRepository.save(entity);

        // Queue async
        queueForEnrichment(entityId).subscribe();
    }

    /**
     * Get enrichment statistics.
     */
    public EnrichmentStats getStatistics() {
        // Query counts by status
        Map<EnrichmentStatus, Long> counts = entityRepository.countByEnrichmentStatus();

        long total = counts.values().stream().mapToLong(Long::longValue).sum();
        long complete = counts.getOrDefault(EnrichmentStatus.COMPLETE, 0L);
        long failed = counts.getOrDefault(EnrichmentStatus.FAILED, 0L);
        long pending = counts.getOrDefault(EnrichmentStatus.PENDING, 0L);

        return EnrichmentStats.builder()
            .totalEntities(total)
            .byStatus(counts)
            .successRate(total > 0 ? (double) complete / total : 0)
            .failureRate(total > 0 ? (double) failed / total : 0)
            .pending(pending)
            .build();
    }
}
```

### EnrichmentController

```java
package org.newsanalyzer.controller;

import org.springframework.web.bind.annotation.*;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;

@RestController
@RequestMapping("/api/entities")
@Tag(name = "Entity Enrichment", description = "External knowledge base enrichment")
public class EnrichmentController {

    private final EnrichmentService enrichmentService;
    private final EntityService entityService;

    @PostMapping("/{id}/enrich")
    @Operation(summary = "Trigger enrichment for entity")
    public ResponseEntity<Map<String, Object>> triggerEnrichment(@PathVariable UUID id) {
        enrichmentService.triggerEnrichment(id);
        return ResponseEntity.ok(Map.of(
            "status", "queued",
            "entityId", id,
            "message", "Entity queued for enrichment"
        ));
    }

    @PostMapping("/enrich/bulk")
    @Operation(summary = "Trigger enrichment for multiple entities")
    public ResponseEntity<Map<String, Object>> triggerBulkEnrichment(
            @RequestBody List<UUID> entityIds) {
        entityIds.forEach(enrichmentService::triggerEnrichment);
        return ResponseEntity.ok(Map.of(
            "status", "queued",
            "count", entityIds.size(),
            "message", "Entities queued for enrichment"
        ));
    }

    @GetMapping("/{id}/enrichment-status")
    @Operation(summary = "Get enrichment status for entity")
    public ResponseEntity<EnrichmentStatusDTO> getEnrichmentStatus(@PathVariable UUID id) {
        Entity entity = entityService.findById(id);
        return ResponseEntity.ok(EnrichmentStatusDTO.builder()
            .entityId(id)
            .status(entity.getEnrichmentStatus())
            .enrichedAt(entity.getEnrichedAt())
            .error(entity.getEnrichmentError())
            .retryCount(entity.getEnrichmentRetryCount())
            .wikidataId(entity.getWikidataId())
            .dbpediaUri(entity.getDbpediaUri())
            .build());
    }

    @GetMapping("/enrichment/stats")
    @Operation(summary = "Get enrichment pipeline statistics")
    public ResponseEntity<EnrichmentStats> getEnrichmentStats() {
        return ResponseEntity.ok(enrichmentService.getStatistics());
    }
}
```

### Integration with EntityService

```java
// Modify EntityService.java createEntity method

@Transactional
public Entity createEntity(CreateEntityRequest request) {
    Entity entity = new Entity();
    // ... existing entity setup ...

    entity.setEnrichmentStatus(EnrichmentStatus.PENDING);
    entity = entityRepository.save(entity);

    // Queue for async enrichment (non-blocking)
    final UUID entityId = entity.getId();
    enrichmentService.queueForEnrichment(entityId)
        .doOnError(e -> log.warn("Failed to queue enrichment for {}", entityId, e))
        .subscribe();

    return entity;
}
```

### Configuration

```yaml
# application.yml
enrichment:
  service:
    url: ${ENRICHMENT_SERVICE_URL:http://localhost:8000}
    timeout: 5s
    circuit-breaker:
      failure-rate-threshold: 50
      wait-duration-in-open-state: 60s
      sliding-window-size: 10
```

## Testing

### Test File Location
- `backend/src/test/java/org/newsanalyzer/service/EnrichmentServiceTest.java`
- `backend/src/test/java/org/newsanalyzer/controller/EnrichmentControllerTest.java`

### Testing Standards
- Use JUnit 5 + Mockito
- Mock WebClient for external calls
- Test circuit breaker behavior
- Minimum 80% coverage

### Test Cases
```java
@Test
void createEntity_triggersEnrichmentAsync() {
    // Test entity creation queues enrichment
}

@Test
void triggerEnrichment_resetsStatus() {
    // Test manual enrichment resets status to PENDING
}

@Test
void enrichmentService_unavailable_fallbackWorks() {
    // Test circuit breaker fallback
}

@Test
void getEnrichmentStatus_returnsCorrectStatus() {
    // Test status endpoint returns current status
}

@Test
void bulkEnrichment_queuesAllEntities() {
    // Test bulk endpoint queues all provided IDs
}

@Test
void entityDTO_includesEnrichmentFields() {
    // Test DTO contains enrichment fields
}

@Test
void migration_addsColumns() {
    // Test V5 migration adds required columns
}
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-25 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_
