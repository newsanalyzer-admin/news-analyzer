# Story 2.2.3: Enrichment Pipeline Orchestration

## Status
Draft

## Story
**As a** system,
**I want to** run entity enrichment as a background pipeline,
**so that** entity extraction is not blocked by external API calls.

## Acceptance Criteria
1. Queue entities for enrichment after extraction
2. Process queue asynchronously (background worker)
3. Support batch processing (50 entities at a time)
4. Retry failed enrichments with exponential backoff
5. Track enrichment status per entity (PENDING, LINKING, ENRICHING, COMPLETE, FAILED)
6. Provide enrichment statistics endpoint
7. Support manual re-enrichment trigger
8. Handle graceful shutdown (complete in-progress, save queue)

## Tasks / Subtasks
- [ ] Create EnrichmentPipeline class (AC: 1, 2)
  - [ ] Implement queue management
  - [ ] Create background worker loop
  - [ ] Coordinate linking and property extraction
- [ ] Implement batch processing (AC: 3)
  - [ ] Fetch batch of PENDING entities
  - [ ] Process in parallel with rate limiting
  - [ ] Update status after each entity
- [ ] Add retry logic (AC: 4)
  - [ ] Implement exponential backoff (1s, 2s, 4s, 8s)
  - [ ] Track retry count per entity
  - [ ] Mark as FAILED after max retries (3)
- [ ] Implement status tracking (AC: 5)
  - [ ] Define status enum
  - [ ] Update database with status changes
  - [ ] Store error messages for failures
- [ ] Create statistics endpoint (AC: 6)
  - [ ] Count entities by status
  - [ ] Calculate success rate
  - [ ] Show average processing time
- [ ] Add manual re-enrichment (AC: 7)
  - [ ] API endpoint to queue specific entity
  - [ ] Reset status to PENDING
  - [ ] Allow enrichment of already-enriched entities
- [ ] Handle shutdown (AC: 8)
  - [ ] Signal handler for graceful stop
  - [ ] Complete current batch
  - [ ] Persist queue state
- [ ] Write integration tests
  - [ ] Test full pipeline flow
  - [ ] Test retry behavior
  - [ ] Test batch processing

## Dev Notes

### Relevant Source Tree
```
reasoning-service/
├── app/
│   ├── services/
│   │   ├── enrichment_pipeline.py  # NEW - Create this file
│   │   ├── entity_linker.py        # Story 2.1.4 - linking
│   │   ├── property_extractor.py   # Story 2.2.1 - properties
│   │   └── property_merger.py      # Story 2.2.2 - merging
│   └── api/
│       └── enrichment.py           # NEW - Statistics endpoint
└── tests/
    └── test_enrichment_pipeline.py # NEW - Create this file
```

### Pipeline States

```
PENDING → LINKING → LINKED → ENRICHING → ENRICHED → COMPLETE
    ↓         ↓          ↓           ↓
 (queue)   (error)    (error)     (error)
    ↓         ↓          ↓           ↓
PENDING   LINK_FAILED   LINK_FAILED   ENRICH_FAILED
    ↓         ↓          ↓           ↓
 (retry)   (retry)    (retry)     (retry)
    ↓         ↓          ↓           ↓
 PENDING    FAILED      FAILED      FAILED
           (max retries) (max retries) (max retries)
```

### EnrichmentPipeline Class

```python
import asyncio
from typing import Optional, List
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
import logging

logger = logging.getLogger("enrichment_pipeline")

class EnrichmentStatus(str, Enum):
    PENDING = "PENDING"
    LINKING = "LINKING"
    LINK_FAILED = "LINK_FAILED"
    ENRICHING = "ENRICHING"
    ENRICH_FAILED = "ENRICH_FAILED"
    COMPLETE = "COMPLETE"
    FAILED = "FAILED"

@dataclass
class EnrichmentTask:
    entity_id: str
    status: EnrichmentStatus
    retry_count: int = 0
    error_message: Optional[str] = None
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None

class EnrichmentPipeline:
    MAX_RETRIES = 3
    BATCH_SIZE = 50
    RETRY_DELAYS = [1, 2, 4, 8]  # Exponential backoff

    def __init__(
        self,
        entity_linker,
        property_extractor,
        property_merger,
        db_session
    ):
        self.linker = entity_linker
        self.extractor = property_extractor
        self.merger = property_merger
        self.db = db_session
        self._running = False
        self._shutdown_event = asyncio.Event()

    async def start(self):
        """Start the background enrichment worker."""
        self._running = True
        logger.info("Enrichment pipeline started")

        while self._running:
            try:
                # Fetch batch of pending entities
                batch = await self._fetch_pending_batch()

                if not batch:
                    # No work, sleep and check again
                    await asyncio.sleep(5)
                    continue

                # Process batch
                await self._process_batch(batch)

            except Exception as e:
                logger.exception(f"Pipeline error: {e}")
                await asyncio.sleep(10)  # Back off on errors

        logger.info("Enrichment pipeline stopped")

    async def stop(self):
        """Gracefully stop the pipeline."""
        logger.info("Stopping enrichment pipeline...")
        self._running = False
        self._shutdown_event.set()

    async def _fetch_pending_batch(self) -> List[EnrichmentTask]:
        """Fetch batch of entities needing enrichment."""
        # Query database for PENDING entities
        query = """
            SELECT id, enrichment_status, enrichment_retry_count
            FROM entities
            WHERE enrichment_status IN ('PENDING', 'LINK_FAILED', 'ENRICH_FAILED')
              AND enrichment_retry_count < :max_retries
            ORDER BY created_at
            LIMIT :batch_size
        """
        results = await self.db.execute(
            query,
            {"max_retries": self.MAX_RETRIES, "batch_size": self.BATCH_SIZE}
        )

        return [
            EnrichmentTask(
                entity_id=row["id"],
                status=EnrichmentStatus(row["enrichment_status"]),
                retry_count=row["enrichment_retry_count"] or 0
            )
            for row in results
        ]

    async def _process_batch(self, batch: List[EnrichmentTask]):
        """Process a batch of entities concurrently."""
        tasks = [self._process_entity(task) for task in batch]
        await asyncio.gather(*tasks, return_exceptions=True)

    async def _process_entity(self, task: EnrichmentTask):
        """Process single entity through enrichment pipeline."""
        entity_id = task.entity_id

        try:
            # STEP 1: Linking
            await self._update_status(entity_id, EnrichmentStatus.LINKING)

            entity = await self._fetch_entity(entity_id)
            link_result = await self.linker.link_entity(
                text=entity["name"],
                entity_type=entity["entity_type"],
                context=entity.get("context")
            )

            if not link_result.wikidata_id and not link_result.dbpedia_uri:
                # No link found - mark as complete (no enrichment possible)
                await self._update_status(
                    entity_id,
                    EnrichmentStatus.COMPLETE,
                    note="No external link found"
                )
                return

            # STEP 2: Property extraction
            await self._update_status(entity_id, EnrichmentStatus.ENRICHING)

            external_props = {}
            if link_result.wikidata_id:
                external_props = await self.extractor.extract_properties(
                    wikidata_id=link_result.wikidata_id,
                    entity_type=entity["entity_type"]
                )

            # STEP 3: Merge properties
            merged, provenance, report = self.merger.merge(
                entity_id=entity_id,
                local_properties=entity.get("properties", {}),
                external_properties=external_props,
                external_source=link_result.linking_source
            )

            # STEP 4: Update entity
            await self._save_enriched_entity(
                entity_id=entity_id,
                properties=merged,
                provenance=provenance,
                wikidata_id=link_result.wikidata_id,
                dbpedia_uri=link_result.dbpedia_uri,
                linking_confidence=link_result.linking_confidence
            )

            await self._update_status(entity_id, EnrichmentStatus.COMPLETE)
            logger.info(f"Entity {entity_id} enriched successfully")

        except Exception as e:
            logger.exception(f"Enrichment failed for {entity_id}: {e}")
            await self._handle_failure(task, str(e))

    async def _handle_failure(self, task: EnrichmentTask, error: str):
        """Handle enrichment failure with retry logic."""
        new_retry_count = task.retry_count + 1

        if new_retry_count >= self.MAX_RETRIES:
            # Max retries exceeded
            await self._update_status(
                task.entity_id,
                EnrichmentStatus.FAILED,
                error=error,
                retry_count=new_retry_count
            )
            logger.error(f"Entity {task.entity_id} failed after {new_retry_count} retries")
        else:
            # Schedule retry
            delay = self.RETRY_DELAYS[min(new_retry_count - 1, len(self.RETRY_DELAYS) - 1)]
            await asyncio.sleep(delay)

            # Reset to pending for retry
            await self._update_status(
                task.entity_id,
                EnrichmentStatus.PENDING,
                error=error,
                retry_count=new_retry_count
            )
            logger.warning(f"Entity {task.entity_id} queued for retry #{new_retry_count}")

    async def _update_status(
        self,
        entity_id: str,
        status: EnrichmentStatus,
        error: str = None,
        retry_count: int = None,
        note: str = None
    ):
        """Update entity enrichment status in database."""
        update_fields = {"enrichment_status": status.value}

        if status == EnrichmentStatus.COMPLETE:
            update_fields["enriched_at"] = datetime.utcnow()
        if error:
            update_fields["enrichment_error"] = error
        if retry_count is not None:
            update_fields["enrichment_retry_count"] = retry_count

        await self.db.execute(
            "UPDATE entities SET ... WHERE id = :id",
            {"id": entity_id, **update_fields}
        )

    async def queue_entity(self, entity_id: str):
        """Manually queue an entity for enrichment."""
        await self._update_status(
            entity_id,
            EnrichmentStatus.PENDING,
            retry_count=0
        )
        logger.info(f"Entity {entity_id} queued for enrichment")

    async def get_statistics(self) -> dict:
        """Get enrichment pipeline statistics."""
        query = """
            SELECT
                enrichment_status,
                COUNT(*) as count
            FROM entities
            GROUP BY enrichment_status
        """
        results = await self.db.execute(query)

        stats = {row["enrichment_status"]: row["count"] for row in results}

        total = sum(stats.values())
        complete = stats.get("COMPLETE", 0)
        failed = stats.get("FAILED", 0)

        return {
            "total_entities": total,
            "by_status": stats,
            "success_rate": complete / total if total > 0 else 0,
            "failure_rate": failed / total if total > 0 else 0,
            "pending": stats.get("PENDING", 0),
            "in_progress": stats.get("LINKING", 0) + stats.get("ENRICHING", 0)
        }
```

### Statistics API Endpoint

```python
# app/api/enrichment.py

from fastapi import APIRouter
from pydantic import BaseModel

router = APIRouter()

class EnrichmentStats(BaseModel):
    total_entities: int
    by_status: dict
    success_rate: float
    failure_rate: float
    pending: int
    in_progress: int

@router.get("/enrichment/stats", response_model=EnrichmentStats)
async def get_enrichment_stats():
    """Get enrichment pipeline statistics."""
    from app.services.enrichment_pipeline import get_pipeline
    pipeline = get_pipeline()
    return await pipeline.get_statistics()

@router.post("/enrichment/queue/{entity_id}")
async def queue_for_enrichment(entity_id: str):
    """Queue a specific entity for enrichment."""
    from app.services.enrichment_pipeline import get_pipeline
    pipeline = get_pipeline()
    await pipeline.queue_entity(entity_id)
    return {"status": "queued", "entity_id": entity_id}
```

### Database Schema Update

This requires the Java backend migration from the implementation plan:

```sql
-- Part of V5 migration
ALTER TABLE entities
ADD COLUMN enrichment_status VARCHAR(20) DEFAULT 'PENDING',
ADD COLUMN enrichment_error TEXT,
ADD COLUMN enrichment_retry_count INTEGER DEFAULT 0,
ADD COLUMN enriched_at TIMESTAMP;
```

## Testing

### Test File Location
`reasoning-service/tests/test_enrichment_pipeline.py`

### Testing Standards
- Use pytest framework with pytest-asyncio
- Mock external services (linker, extractor)
- Test async behavior
- Minimum 90% coverage

### Test Cases
```python
@pytest.mark.asyncio
async def test_pipeline_processes_pending_entities():
    """Test pipeline fetches and processes PENDING entities"""

@pytest.mark.asyncio
async def test_batch_processing():
    """Test entities processed in batches of 50"""

@pytest.mark.asyncio
async def test_retry_on_failure():
    """Test failed entity retried with backoff"""

@pytest.mark.asyncio
async def test_max_retries_exceeded():
    """Test entity marked FAILED after 3 retries"""

@pytest.mark.asyncio
async def test_status_transitions():
    """Test correct status flow: PENDING → LINKING → ENRICHING → COMPLETE"""

@pytest.mark.asyncio
async def test_manual_queue():
    """Test manually queuing entity for enrichment"""

@pytest.mark.asyncio
async def test_statistics_endpoint():
    """Test statistics accurately reflect entity states"""

@pytest.mark.asyncio
async def test_graceful_shutdown():
    """Test pipeline completes current work on shutdown"""

@pytest.mark.asyncio
async def test_no_link_still_completes():
    """Test entity without external link marked COMPLETE"""
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-25 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_
