# Story 2.4.3: Bulk Validation Report

## Status
Draft

## Story
**As an** administrator,
**I want to** run validation on all existing entities and generate a report,
**so that** I can identify and fix data quality issues across the entire database.

## Acceptance Criteria
1. Create validation job for all entities in database
2. Generate report with error counts by type and property
3. Identify entities needing manual correction
4. Export validation results as CSV
5. Schedule weekly validation report
6. Track validation trends over time
7. Send notification when report is ready

## Tasks / Subtasks
- [ ] Create BulkValidationService (AC: 1)
  - [ ] Query all entities in batches
  - [ ] Validate each batch
  - [ ] Aggregate results
  - [ ] Handle large datasets efficiently
- [ ] Generate validation report (AC: 2, 3)
  - [ ] Count errors by entity type
  - [ ] Count errors by property
  - [ ] List entities with most errors
  - [ ] Calculate overall validation rate
- [ ] Implement CSV export (AC: 4)
  - [ ] Generate CSV with entity ID, errors
  - [ ] Include all validation details
  - [ ] Support filtering (errors only, warnings only)
- [ ] Create scheduled job (AC: 5)
  - [ ] Weekly schedule (Sunday 3 AM)
  - [ ] Store report history
  - [ ] Configurable schedule
- [ ] Track trends (AC: 6)
  - [ ] Store weekly validation stats
  - [ ] Calculate week-over-week change
  - [ ] Track validation rate improvement
- [ ] Add notifications (AC: 7)
  - [ ] Email when report ready
  - [ ] Include summary in notification
  - [ ] Link to full report
- [ ] Write tests
  - [ ] Test batch processing
  - [ ] Test report generation
  - [ ] Test CSV export
  - [ ] Test scheduling

## Dev Notes

### Relevant Source Tree
```
backend/src/main/java/org/newsanalyzer/
├── service/
│   └── BulkValidationService.java   # NEW - Create this file
├── scheduler/
│   └── ValidationReportScheduler.java # NEW
├── dto/
│   └── ValidationReportDTO.java     # NEW
└── controller/
    └── ValidationReportController.java # NEW

backend/src/main/resources/
└── templates/
    └── validation-report-email.html # NEW - Email template

backend/src/test/java/org/newsanalyzer/
└── service/BulkValidationServiceTest.java # NEW
```

### BulkValidationService Implementation

```java
package org.newsanalyzer.service;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;
import lombok.extern.slf4j.Slf4j;

@Service
@Slf4j
public class BulkValidationService {

    private static final int BATCH_SIZE = 100;

    private final EntityRepository entityRepository;
    private final JsonLdService jsonLdService;
    private final ValidationReportRepository reportRepository;
    private final WebClient webClient;

    @Value("${validation.service.url}")
    private String validationServiceUrl;

    /**
     * Run validation on all entities and generate report.
     */
    @Async
    public CompletableFuture<ValidationReport> runFullValidation() {
        log.info("Starting bulk validation");
        long startTime = System.currentTimeMillis();

        ValidationReport report = new ValidationReport();
        report.setStartedAt(LocalDateTime.now());
        report.setStatus(ValidationReportStatus.RUNNING);
        report = reportRepository.save(report);

        try {
            // Process in batches
            int page = 0;
            long totalEntities = 0;
            long validEntities = 0;
            Map<String, Integer> errorsByType = new HashMap<>();
            Map<String, Integer> errorsByProperty = new HashMap<>();
            List<EntityValidationSummary> invalidEntities = new ArrayList<>();

            Page<Entity> entityPage;
            do {
                entityPage = entityRepository.findAll(PageRequest.of(page, BATCH_SIZE));
                log.info("Processing batch {} ({} entities)",
                    page + 1, entityPage.getNumberOfElements());

                // Convert to JSON-LD and validate
                List<Map<String, Object>> jsonLdBatch = entityPage.getContent()
                    .stream()
                    .map(jsonLdService::generateJsonLd)
                    .collect(Collectors.toList());

                ValidationResponse batchResult = validateBatch(jsonLdBatch);

                // Aggregate results
                for (int i = 0; i < batchResult.getResults().size(); i++) {
                    EntityValidationResult result = batchResult.getResults().get(i);
                    Entity entity = entityPage.getContent().get(i);

                    totalEntities++;
                    if (result.isValid()) {
                        validEntities++;
                    } else {
                        // Track errors by type
                        String entityType = entity.getSchemaOrgType();
                        errorsByType.merge(entityType, 1, Integer::sum);

                        // Track errors by property
                        for (ValidationError error : result.getErrors()) {
                            errorsByProperty.merge(error.getProperty(), 1, Integer::sum);
                        }

                        // Add to invalid list (limit to top 1000)
                        if (invalidEntities.size() < 1000) {
                            invalidEntities.add(EntityValidationSummary.builder()
                                .entityId(entity.getId())
                                .entityName(entity.getName())
                                .entityType(entityType)
                                .errorCount(result.getErrorCount())
                                .errors(result.getErrors())
                                .build());
                        }
                    }
                }

                page++;
            } while (entityPage.hasNext());

            // Finalize report
            report.setCompletedAt(LocalDateTime.now());
            report.setStatus(ValidationReportStatus.COMPLETED);
            report.setTotalEntities(totalEntities);
            report.setValidEntities(validEntities);
            report.setInvalidEntities(totalEntities - validEntities);
            report.setValidationRate((double) validEntities / totalEntities);
            report.setErrorsByType(errorsByType);
            report.setErrorsByProperty(errorsByProperty);
            report.setInvalidEntitySummaries(invalidEntities);
            report.setDurationMs(System.currentTimeMillis() - startTime);

            reportRepository.save(report);
            log.info("Bulk validation completed: {}/{} valid ({}%)",
                validEntities, totalEntities,
                String.format("%.1f", report.getValidationRate() * 100));

            return CompletableFuture.completedFuture(report);

        } catch (Exception e) {
            log.error("Bulk validation failed", e);
            report.setStatus(ValidationReportStatus.FAILED);
            report.setErrorMessage(e.getMessage());
            reportRepository.save(report);
            throw e;
        }
    }

    private ValidationResponse validateBatch(List<Map<String, Object>> entities) {
        return webClient.post()
            .uri(validationServiceUrl + "/entities/validate")
            .bodyValue(Map.of("entities", entities, "level", "strict"))
            .retrieve()
            .bodyToMono(ValidationResponse.class)
            .block(Duration.ofMinutes(5));
    }

    /**
     * Export validation report as CSV.
     */
    public String exportReportAsCsv(UUID reportId) {
        ValidationReport report = reportRepository.findById(reportId)
            .orElseThrow(() -> new ReportNotFoundException(reportId));

        StringBuilder csv = new StringBuilder();
        csv.append("Entity ID,Entity Name,Entity Type,Error Count,Errors\n");

        for (EntityValidationSummary summary : report.getInvalidEntitySummaries()) {
            csv.append(summary.getEntityId()).append(",");
            csv.append(escapeCsv(summary.getEntityName())).append(",");
            csv.append(summary.getEntityType()).append(",");
            csv.append(summary.getErrorCount()).append(",");
            csv.append(escapeCsv(formatErrors(summary.getErrors()))).append("\n");
        }

        return csv.toString();
    }

    private String escapeCsv(String value) {
        if (value == null) return "";
        if (value.contains(",") || value.contains("\"") || value.contains("\n")) {
            return "\"" + value.replace("\"", "\"\"") + "\"";
        }
        return value;
    }

    private String formatErrors(List<ValidationError> errors) {
        return errors.stream()
            .map(e -> e.getProperty() + ": " + e.getMessage())
            .collect(Collectors.joining("; "));
    }

    /**
     * Get validation trends over time.
     */
    public List<ValidationTrend> getValidationTrends(int weeks) {
        LocalDateTime since = LocalDateTime.now().minusWeeks(weeks);
        List<ValidationReport> reports = reportRepository
            .findByCompletedAtAfterOrderByCompletedAtDesc(since);

        return reports.stream()
            .map(r -> ValidationTrend.builder()
                .date(r.getCompletedAt().toLocalDate())
                .totalEntities(r.getTotalEntities())
                .validEntities(r.getValidEntities())
                .validationRate(r.getValidationRate())
                .build())
            .collect(Collectors.toList());
    }
}
```

### ValidationReportScheduler

```java
package org.newsanalyzer.scheduler;

import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

@Component
@Slf4j
public class ValidationReportScheduler {

    private final BulkValidationService bulkValidationService;
    private final NotificationService notificationService;

    @Scheduled(cron = "${validation.report.schedule:0 0 3 * * SUN}") // Sunday 3 AM
    public void runWeeklyValidationReport() {
        log.info("Starting scheduled weekly validation report");

        try {
            CompletableFuture<ValidationReport> future =
                bulkValidationService.runFullValidation();

            ValidationReport report = future.get(30, TimeUnit.MINUTES);

            // Send notification
            notificationService.sendValidationReportNotification(report);

            log.info("Weekly validation report completed: {} validation rate",
                String.format("%.1f%%", report.getValidationRate() * 100));

        } catch (Exception e) {
            log.error("Weekly validation report failed", e);
            notificationService.sendValidationReportFailureNotification(e.getMessage());
        }
    }
}
```

### ValidationReportController

```java
package org.newsanalyzer.controller;

@RestController
@RequestMapping("/api/validation-reports")
@Tag(name = "Validation Reports", description = "Bulk validation reports")
public class ValidationReportController {

    private final BulkValidationService bulkValidationService;
    private final ValidationReportRepository reportRepository;

    @PostMapping("/run")
    @Operation(summary = "Trigger bulk validation")
    public ResponseEntity<Map<String, Object>> triggerValidation() {
        bulkValidationService.runFullValidation();
        return ResponseEntity.accepted().body(Map.of(
            "status", "started",
            "message", "Bulk validation started. Check /reports for results."
        ));
    }

    @GetMapping
    @Operation(summary = "List validation reports")
    public ResponseEntity<List<ValidationReportSummaryDTO>> listReports(
            @RequestParam(defaultValue = "10") int limit
    ) {
        List<ValidationReport> reports = reportRepository
            .findTop10ByOrderByCompletedAtDesc();
        return ResponseEntity.ok(reports.stream()
            .map(ValidationReportSummaryDTO::from)
            .collect(Collectors.toList()));
    }

    @GetMapping("/{id}")
    @Operation(summary = "Get validation report details")
    public ResponseEntity<ValidationReportDTO> getReport(@PathVariable UUID id) {
        ValidationReport report = reportRepository.findById(id)
            .orElseThrow(() -> new ReportNotFoundException(id));
        return ResponseEntity.ok(ValidationReportDTO.from(report));
    }

    @GetMapping("/{id}/csv")
    @Operation(summary = "Export report as CSV")
    public ResponseEntity<String> exportCsv(@PathVariable UUID id) {
        String csv = bulkValidationService.exportReportAsCsv(id);
        return ResponseEntity.ok()
            .contentType(MediaType.parseMediaType("text/csv"))
            .header("Content-Disposition", "attachment; filename=validation-report.csv")
            .body(csv);
    }

    @GetMapping("/trends")
    @Operation(summary = "Get validation trends")
    public ResponseEntity<List<ValidationTrend>> getTrends(
            @RequestParam(defaultValue = "12") int weeks
    ) {
        return ResponseEntity.ok(bulkValidationService.getValidationTrends(weeks));
    }

    @GetMapping("/latest")
    @Operation(summary = "Get latest report")
    public ResponseEntity<ValidationReportDTO> getLatestReport() {
        ValidationReport report = reportRepository.findTopByOrderByCompletedAtDesc()
            .orElseThrow(() -> new NoReportsException());
        return ResponseEntity.ok(ValidationReportDTO.from(report));
    }
}
```

### Report DTOs

```java
@Data
@Builder
public class ValidationReportDTO {
    private UUID id;
    private LocalDateTime startedAt;
    private LocalDateTime completedAt;
    private String status;
    private long totalEntities;
    private long validEntities;
    private long invalidEntities;
    private double validationRate;
    private long durationMs;
    private Map<String, Integer> errorsByType;
    private Map<String, Integer> errorsByProperty;
    private List<EntityValidationSummary> topInvalidEntities;

    public static ValidationReportDTO from(ValidationReport report) {
        return ValidationReportDTO.builder()
            .id(report.getId())
            .startedAt(report.getStartedAt())
            .completedAt(report.getCompletedAt())
            .status(report.getStatus().name())
            .totalEntities(report.getTotalEntities())
            .validEntities(report.getValidEntities())
            .invalidEntities(report.getInvalidEntities())
            .validationRate(report.getValidationRate())
            .durationMs(report.getDurationMs())
            .errorsByType(report.getErrorsByType())
            .errorsByProperty(report.getErrorsByProperty())
            .topInvalidEntities(report.getInvalidEntitySummaries().stream()
                .limit(100)
                .collect(Collectors.toList()))
            .build();
    }
}

@Data
@Builder
public class ValidationTrend {
    private LocalDate date;
    private long totalEntities;
    private long validEntities;
    private double validationRate;
}
```

### Email Notification Template

```html
<!-- templates/validation-report-email.html -->
<!DOCTYPE html>
<html>
<head>
    <style>
        body { font-family: Arial, sans-serif; }
        .stats { background: #f5f5f5; padding: 15px; border-radius: 5px; }
        .good { color: green; }
        .warning { color: orange; }
        .bad { color: red; }
    </style>
</head>
<body>
    <h1>Weekly Validation Report</h1>
    <p>Completed: {{completedAt}}</p>

    <div class="stats">
        <h2>Summary</h2>
        <p>Total Entities: <strong>{{totalEntities}}</strong></p>
        <p>Valid: <strong class="{{validationClass}}">{{validEntities}} ({{validationRate}}%)</strong></p>
        <p>Invalid: <strong>{{invalidEntities}}</strong></p>
        <p>Duration: {{durationSeconds}} seconds</p>
    </div>

    <h2>Errors by Entity Type</h2>
    <ul>
    {{#errorsByType}}
        <li>{{type}}: {{count}} errors</li>
    {{/errorsByType}}
    </ul>

    <h2>Most Common Errors</h2>
    <ul>
    {{#topErrors}}
        <li>{{property}}: {{count}} occurrences</li>
    {{/topErrors}}
    </ul>

    <p><a href="{{reportUrl}}">View Full Report</a></p>
    <p><a href="{{csvUrl}}">Download CSV</a></p>
</body>
</html>
```

### Configuration

```yaml
# application.yml
validation:
  report:
    schedule: "0 0 3 * * SUN"  # Sunday 3 AM
    notification:
      enabled: true
      email: admin@newsanalyzer.org
```

## Testing

### Test File Location
`backend/src/test/java/org/newsanalyzer/service/BulkValidationServiceTest.java`

### Testing Standards
- Use JUnit 5
- Mock external services
- Test batch processing
- Minimum 80% coverage

### Test Cases
```java
@Test
void runFullValidation_processesAllEntities() {
    // Test all entities processed in batches
}

@Test
void runFullValidation_aggregatesErrorsByType() {
    // Test error aggregation correct
}

@Test
void runFullValidation_limitsInvalidList() {
    // Test max 1000 invalid entities stored
}

@Test
void exportReportAsCsv_correctFormat() {
    // Test CSV output format
}

@Test
void exportReportAsCsv_escapesSpecialChars() {
    // Test CSV escaping
}

@Test
void getValidationTrends_returnsCorrectPeriod() {
    // Test trend data for specified weeks
}

@Test
void scheduler_runsOnSchedule() {
    // Test scheduler triggers correctly
}

@Test
void notification_sentOnCompletion() {
    // Test email sent when report done
}
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-25 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_
