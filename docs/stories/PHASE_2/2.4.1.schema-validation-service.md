# Story 2.4.1: Schema.org Validation Service

## Status
Draft

## Story
**As a** system,
**I want to** validate entity JSON-LD against Schema.org vocabulary,
**so that** all entity data is standards-compliant and interoperable.

## Acceptance Criteria
1. Validate `@type` is valid Schema.org type
2. Validate required properties per type (e.g., name required for all)
3. Validate property value types (string, date, URL, etc.)
4. Return detailed validation errors with line/property reference
5. Support batch validation
6. Cache Schema.org vocabulary locally for performance
7. Support validation levels: strict (all rules) and lenient (required only)

## Tasks / Subtasks
- [ ] Create SchemaValidator class (AC: 1, 2, 3)
  - [ ] Load Schema.org vocabulary
  - [ ] Implement type validation
  - [ ] Implement property validation
  - [ ] Implement value type validation
- [ ] Implement detailed error reporting (AC: 4)
  - [ ] Create ValidationError class
  - [ ] Include property path in errors
  - [ ] Include expected vs actual values
  - [ ] Categorize errors (type, required, format)
- [ ] Add batch validation (AC: 5)
  - [ ] Accept list of entities
  - [ ] Validate in parallel
  - [ ] Aggregate results
- [ ] Implement vocabulary caching (AC: 6)
  - [ ] Download Schema.org JSON-LD vocab
  - [ ] Cache locally (file or memory)
  - [ ] Refresh monthly
- [ ] Add validation levels (AC: 7)
  - [ ] STRICT: All rules enforced
  - [ ] LENIENT: Required properties only
  - [ ] Configurable per request
- [ ] Write unit tests
  - [ ] Test valid entities pass
  - [ ] Test invalid type caught
  - [ ] Test missing required caught
  - [ ] Test format errors caught

## Dev Notes

### Relevant Source Tree
```
reasoning-service/
├── app/
│   ├── services/
│   │   └── schema_validator.py  # NEW - Create this file
│   └── api/
│       └── validation.py        # NEW - Validation endpoints
├── data/
│   └── schema-org-vocab.json    # NEW - Cached vocabulary
└── tests/
    └── test_schema_validator.py # NEW
```

### Schema.org Vocabulary Source

Download from: https://schema.org/version/latest/schemaorg-current-https.jsonld

Or use the simpler type list: https://schema.org/docs/full.html

### Validation Rules by Type

#### All Types (Thing)
- **Required**: name
- **Optional**: description, url, alternateName, sameAs, identifier

#### Person
- **Required**: name
- **Expected**: jobTitle, birthDate, nationality
- **Format**: birthDate must be ISO date, url must be valid URL

#### Organization / GovernmentOrganization
- **Required**: name
- **Expected**: url, foundingDate, location
- **Format**: foundingDate must be ISO date

#### Place
- **Required**: name
- **Expected**: geo, address
- **Format**: geo must have latitude/longitude

### SchemaValidator Implementation

```python
from typing import Dict, Any, List, Optional
from dataclasses import dataclass, field
from enum import Enum
import json
import re

class ValidationLevel(str, Enum):
    STRICT = "strict"
    LENIENT = "lenient"

class ErrorSeverity(str, Enum):
    ERROR = "error"      # Must fix
    WARNING = "warning"  # Should fix
    INFO = "info"        # Suggestion

@dataclass
class ValidationError:
    property_path: str
    message: str
    severity: ErrorSeverity
    expected: Optional[str] = None
    actual: Optional[str] = None
    rule: Optional[str] = None

@dataclass
class ValidationResult:
    entity_id: Optional[str]
    valid: bool
    errors: List[ValidationError] = field(default_factory=list)
    warnings: List[ValidationError] = field(default_factory=list)

class SchemaValidator:
    # Valid Schema.org types we support
    VALID_TYPES = {
        "Thing", "Person", "Organization", "GovernmentOrganization",
        "Place", "Event", "CreativeWork", "Legislation",
        "PoliticalParty", "NewsMediaOrganization", "Country", "City"
    }

    # Required properties by type
    REQUIRED_PROPERTIES = {
        "Thing": ["name"],
        "Person": ["name"],
        "Organization": ["name"],
        "GovernmentOrganization": ["name"],
        "Place": ["name"],
        "Event": ["name", "startDate"],
    }

    # Expected properties by type (warnings if missing)
    EXPECTED_PROPERTIES = {
        "Person": ["jobTitle", "birthDate"],
        "Organization": ["url"],
        "GovernmentOrganization": ["url", "areaServed"],
        "Place": ["geo", "address"],
        "Event": ["location"],
    }

    # Property format validators
    FORMAT_VALIDATORS = {
        "birthDate": lambda v: SchemaValidator._is_iso_date(v),
        "deathDate": lambda v: SchemaValidator._is_iso_date(v),
        "foundingDate": lambda v: SchemaValidator._is_iso_date(v),
        "startDate": lambda v: SchemaValidator._is_iso_date(v),
        "endDate": lambda v: SchemaValidator._is_iso_date(v),
        "url": lambda v: SchemaValidator._is_valid_url(v),
        "email": lambda v: SchemaValidator._is_valid_email(v),
    }

    def __init__(self, vocab_path: Optional[str] = None):
        self.vocab = self._load_vocabulary(vocab_path)

    def validate(
        self,
        entity: Dict[str, Any],
        level: ValidationLevel = ValidationLevel.LENIENT
    ) -> ValidationResult:
        """Validate entity against Schema.org vocabulary."""
        errors = []
        warnings = []

        entity_id = entity.get("@id") or entity.get("id")

        # 1. Validate @context
        if "@context" not in entity:
            errors.append(ValidationError(
                property_path="@context",
                message="Missing @context",
                severity=ErrorSeverity.ERROR,
                expected="https://schema.org",
                rule="json-ld-context"
            ))
        elif entity["@context"] != "https://schema.org":
            warnings.append(ValidationError(
                property_path="@context",
                message="Non-standard @context",
                severity=ErrorSeverity.WARNING,
                expected="https://schema.org",
                actual=str(entity["@context"]),
                rule="json-ld-context"
            ))

        # 2. Validate @type
        entity_type = entity.get("@type")
        if not entity_type:
            errors.append(ValidationError(
                property_path="@type",
                message="Missing @type",
                severity=ErrorSeverity.ERROR,
                rule="schema-type"
            ))
        elif entity_type not in self.VALID_TYPES:
            errors.append(ValidationError(
                property_path="@type",
                message=f"Invalid Schema.org type: {entity_type}",
                severity=ErrorSeverity.ERROR,
                expected=", ".join(sorted(self.VALID_TYPES)),
                actual=entity_type,
                rule="schema-type"
            ))

        # 3. Validate required properties
        if entity_type:
            required = self.REQUIRED_PROPERTIES.get(entity_type, ["name"])
            for prop in required:
                if prop not in entity or not entity[prop]:
                    errors.append(ValidationError(
                        property_path=prop,
                        message=f"Missing required property: {prop}",
                        severity=ErrorSeverity.ERROR,
                        rule="required-property"
                    ))

        # 4. Validate expected properties (strict mode only)
        if level == ValidationLevel.STRICT and entity_type:
            expected = self.EXPECTED_PROPERTIES.get(entity_type, [])
            for prop in expected:
                if prop not in entity:
                    warnings.append(ValidationError(
                        property_path=prop,
                        message=f"Missing expected property: {prop}",
                        severity=ErrorSeverity.WARNING,
                        rule="expected-property"
                    ))

        # 5. Validate property formats
        for prop, validator in self.FORMAT_VALIDATORS.items():
            if prop in entity and entity[prop]:
                value = entity[prop]
                if not validator(value):
                    errors.append(ValidationError(
                        property_path=prop,
                        message=f"Invalid format for {prop}",
                        severity=ErrorSeverity.ERROR,
                        actual=str(value),
                        rule="property-format"
                    ))

        # 6. Validate nested objects (strict mode)
        if level == ValidationLevel.STRICT:
            nested_errors = self._validate_nested_objects(entity)
            errors.extend(nested_errors)

        return ValidationResult(
            entity_id=entity_id,
            valid=len(errors) == 0,
            errors=errors,
            warnings=warnings
        )

    def validate_batch(
        self,
        entities: List[Dict[str, Any]],
        level: ValidationLevel = ValidationLevel.LENIENT
    ) -> List[ValidationResult]:
        """Validate multiple entities."""
        return [self.validate(e, level) for e in entities]

    def _validate_nested_objects(self, entity: Dict[str, Any], path: str = "") -> List[ValidationError]:
        """Recursively validate nested Schema.org objects."""
        errors = []

        for key, value in entity.items():
            if key.startswith("@"):
                continue

            current_path = f"{path}.{key}" if path else key

            if isinstance(value, dict) and "@type" in value:
                # Nested Schema.org object
                nested_result = self.validate(value, ValidationLevel.LENIENT)
                for error in nested_result.errors:
                    error.property_path = f"{current_path}.{error.property_path}"
                    errors.append(error)

        return errors

    @staticmethod
    def _is_iso_date(value: str) -> bool:
        """Check if value is valid ISO 8601 date."""
        if not isinstance(value, str):
            return False
        pattern = r'^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2})?'
        return bool(re.match(pattern, value))

    @staticmethod
    def _is_valid_url(value: str) -> bool:
        """Check if value is valid URL."""
        if not isinstance(value, str):
            return False
        pattern = r'^https?://[^\s<>"{}|\\^`\[\]]+'
        return bool(re.match(pattern, value))

    @staticmethod
    def _is_valid_email(value: str) -> bool:
        """Check if value is valid email."""
        if not isinstance(value, str):
            return False
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return bool(re.match(pattern, value))

    def _load_vocabulary(self, path: Optional[str]) -> Dict:
        """Load Schema.org vocabulary from file or use defaults."""
        if path:
            try:
                with open(path, 'r') as f:
                    return json.load(f)
            except FileNotFoundError:
                pass
        return {"types": self.VALID_TYPES}


# Singleton instance
_validator_instance = None

def get_validator() -> SchemaValidator:
    global _validator_instance
    if _validator_instance is None:
        _validator_instance = SchemaValidator()
    return _validator_instance
```

### Validation API Endpoint

```python
# app/api/validation.py

from fastapi import APIRouter
from pydantic import BaseModel, Field
from typing import List, Optional
from app.services.schema_validator import (
    get_validator, ValidationLevel, ValidationResult, ValidationError
)

router = APIRouter()

class ValidationRequest(BaseModel):
    entities: List[dict] = Field(..., description="Entities to validate")
    level: ValidationLevel = Field(
        ValidationLevel.LENIENT,
        description="Validation strictness"
    )

class ValidationErrorDTO(BaseModel):
    property_path: str
    message: str
    severity: str
    expected: Optional[str] = None
    actual: Optional[str] = None

class ValidationResultDTO(BaseModel):
    entity_id: Optional[str]
    valid: bool
    errors: List[ValidationErrorDTO]
    warnings: List[ValidationErrorDTO]

class ValidationResponse(BaseModel):
    results: List[ValidationResultDTO]
    valid_count: int
    error_count: int
    total: int

@router.post("/validate", response_model=ValidationResponse)
async def validate_entities(request: ValidationRequest):
    """
    Validate entities against Schema.org vocabulary.

    Levels:
    - lenient: Only required properties checked
    - strict: All rules enforced, including expected properties
    """
    validator = get_validator()
    results = validator.validate_batch(request.entities, request.level)

    valid_count = sum(1 for r in results if r.valid)

    return ValidationResponse(
        results=[
            ValidationResultDTO(
                entity_id=r.entity_id,
                valid=r.valid,
                errors=[ValidationErrorDTO(**e.__dict__) for e in r.errors],
                warnings=[ValidationErrorDTO(**e.__dict__) for e in r.warnings]
            )
            for r in results
        ],
        valid_count=valid_count,
        error_count=len(request.entities) - valid_count,
        total=len(request.entities)
    )
```

## Testing

### Test File Location
`reasoning-service/tests/test_schema_validator.py`

### Testing Standards
- Use pytest framework
- Test all validation rules
- Minimum 95% coverage (critical path)

### Test Cases
```python
def test_valid_entity_passes():
    """Test valid entity returns no errors"""

def test_missing_context_error():
    """Test missing @context returns error"""

def test_invalid_type_error():
    """Test invalid @type returns error"""

def test_missing_name_error():
    """Test missing name returns error"""

def test_invalid_date_format():
    """Test invalid birthDate format caught"""

def test_invalid_url_format():
    """Test invalid url format caught"""

def test_strict_mode_checks_expected():
    """Test strict mode warns on missing expected props"""

def test_lenient_mode_skips_expected():
    """Test lenient mode ignores missing expected props"""

def test_batch_validation():
    """Test multiple entities validated"""

def test_nested_object_validated():
    """Test nested Schema.org objects validated"""

def test_error_includes_path():
    """Test errors include property path"""
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-25 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_
