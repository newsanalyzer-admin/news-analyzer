# Story 2.3.3: Entity Sitemap Generation

## Status
Draft

## Story
**As a** search engine,
**I want to** discover all entity pages via XML sitemap,
**so that** entity pages are indexed and searchable.

## Acceptance Criteria
1. Generate XML sitemap for all public entities
2. Include lastmod timestamps for each entity
3. Support sitemap pagination (50,000 entries per file)
4. Add sitemap to robots.txt
5. Regenerate sitemap daily (scheduled job)
6. Include priority hints based on entity enrichment status
7. Serve sitemap with correct Content-Type

## Tasks / Subtasks
- [ ] Create SitemapService (AC: 1, 2, 6)
  - [ ] Query all public entities
  - [ ] Generate XML sitemap format
  - [ ] Include lastmod from updatedAt
  - [ ] Set priority based on enrichment status
- [ ] Implement sitemap pagination (AC: 3)
  - [ ] Count entities and determine page count
  - [ ] Generate sitemap index file
  - [ ] Generate individual sitemap files
  - [ ] URL pattern: /sitemap-entities-{n}.xml
- [ ] Create sitemap endpoints (AC: 7)
  - [ ] GET /sitemap.xml (index)
  - [ ] GET /sitemap-entities-{page}.xml (paginated)
  - [ ] Return application/xml Content-Type
- [ ] Update robots.txt (AC: 4)
  - [ ] Add Sitemap directive
  - [ ] Serve from public directory
- [ ] Create scheduled regeneration (AC: 5)
  - [ ] Spring @Scheduled job (daily at 2 AM)
  - [ ] Cache generated sitemaps
  - [ ] Log regeneration status
- [ ] Write tests
  - [ ] Test XML format valid
  - [ ] Test pagination correct
  - [ ] Test Content-Type correct

## Dev Notes

### Relevant Source Tree
```
backend/src/main/java/org/newsanalyzer/
├── service/
│   └── SitemapService.java        # NEW - Sitemap generation
├── controller/
│   └── SitemapController.java     # NEW - Sitemap endpoints
└── scheduler/
    └── SitemapScheduler.java      # NEW - Daily regeneration

backend/src/main/resources/
└── static/
    └── robots.txt                 # MODIFY - Add sitemap directive

backend/src/test/java/org/newsanalyzer/
└── service/SitemapServiceTest.java # NEW
```

### Sitemap XML Format

#### Sitemap Index (sitemap.xml)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<sitemapindex xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
  <sitemap>
    <loc>https://newsanalyzer.org/sitemap-entities-1.xml</loc>
    <lastmod>2025-11-25</lastmod>
  </sitemap>
  <sitemap>
    <loc>https://newsanalyzer.org/sitemap-entities-2.xml</loc>
    <lastmod>2025-11-25</lastmod>
  </sitemap>
</sitemapindex>
```

#### Entity Sitemap (sitemap-entities-1.xml)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
  <url>
    <loc>https://newsanalyzer.org/entities/550e8400-e29b-41d4-a716-446655440001</loc>
    <lastmod>2025-11-25T10:30:00Z</lastmod>
    <changefreq>weekly</changefreq>
    <priority>0.8</priority>
  </url>
  <url>
    <loc>https://newsanalyzer.org/entities/550e8400-e29b-41d4-a716-446655440002</loc>
    <lastmod>2025-11-24T15:45:00Z</lastmod>
    <changefreq>weekly</changefreq>
    <priority>0.6</priority>
  </url>
  <!-- ... up to 50,000 URLs per file -->
</urlset>
```

### SitemapService Implementation

```java
package org.newsanalyzer.service;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;

@Service
public class SitemapService {

    private static final int MAX_URLS_PER_SITEMAP = 50000;
    private static final String BASE_URL = "https://newsanalyzer.org";

    private final EntityRepository entityRepository;
    private final Map<String, String> sitemapCache = new ConcurrentHashMap<>();

    public SitemapService(EntityRepository entityRepository) {
        this.entityRepository = entityRepository;
    }

    /**
     * Generate sitemap index listing all sitemap files.
     */
    public String generateSitemapIndex() {
        long totalEntities = entityRepository.countPublicEntities();
        int pageCount = (int) Math.ceil((double) totalEntities / MAX_URLS_PER_SITEMAP);

        StringBuilder xml = new StringBuilder();
        xml.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
        xml.append("<sitemapindex xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n");

        String today = LocalDate.now().toString();

        for (int i = 1; i <= pageCount; i++) {
            xml.append("  <sitemap>\n");
            xml.append("    <loc>").append(BASE_URL).append("/sitemap-entities-")
               .append(i).append(".xml</loc>\n");
            xml.append("    <lastmod>").append(today).append("</lastmod>\n");
            xml.append("  </sitemap>\n");
        }

        xml.append("</sitemapindex>");
        return xml.toString();
    }

    /**
     * Generate paginated entity sitemap.
     */
    public String generateEntitySitemap(int page) {
        // Check cache first
        String cacheKey = "sitemap-entities-" + page;
        if (sitemapCache.containsKey(cacheKey)) {
            return sitemapCache.get(cacheKey);
        }

        // Fetch entities for this page
        PageRequest pageRequest = PageRequest.of(page - 1, MAX_URLS_PER_SITEMAP);
        Page<Entity> entities = entityRepository.findAllPublic(pageRequest);

        StringBuilder xml = new StringBuilder();
        xml.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
        xml.append("<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n");

        for (Entity entity : entities.getContent()) {
            xml.append("  <url>\n");
            xml.append("    <loc>").append(BASE_URL).append("/entities/")
               .append(entity.getId()).append("</loc>\n");
            xml.append("    <lastmod>").append(formatDateTime(entity.getUpdatedAt()))
               .append("</lastmod>\n");
            xml.append("    <changefreq>weekly</changefreq>\n");
            xml.append("    <priority>").append(calculatePriority(entity))
               .append("</priority>\n");
            xml.append("  </url>\n");
        }

        xml.append("</urlset>");

        String result = xml.toString();
        sitemapCache.put(cacheKey, result);
        return result;
    }

    /**
     * Calculate priority based on entity enrichment status.
     */
    private String calculatePriority(Entity entity) {
        if (entity.isEnriched() && entity.getWikidataId() != null) {
            return "0.9";  // Fully enriched with external links
        } else if (entity.isEnriched()) {
            return "0.8";  // Enriched but no external links
        } else if (entity.getVerified()) {
            return "0.7";  // Verified but not enriched
        } else {
            return "0.5";  // Basic entity
        }
    }

    private String formatDateTime(LocalDateTime dateTime) {
        return dateTime.format(DateTimeFormatter.ISO_DATE_TIME);
    }

    /**
     * Clear cache (called by scheduler after regeneration).
     */
    public void clearCache() {
        sitemapCache.clear();
    }

    /**
     * Get sitemap page count.
     */
    public int getPageCount() {
        long totalEntities = entityRepository.countPublicEntities();
        return (int) Math.ceil((double) totalEntities / MAX_URLS_PER_SITEMAP);
    }
}
```

### SitemapController

```java
package org.newsanalyzer.controller;

import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.*;

@RestController
public class SitemapController {

    private final SitemapService sitemapService;

    @GetMapping(value = "/sitemap.xml", produces = MediaType.APPLICATION_XML_VALUE)
    public String getSitemapIndex() {
        return sitemapService.generateSitemapIndex();
    }

    @GetMapping(
        value = "/sitemap-entities-{page}.xml",
        produces = MediaType.APPLICATION_XML_VALUE
    )
    public ResponseEntity<String> getEntitySitemap(@PathVariable int page) {
        int maxPage = sitemapService.getPageCount();
        if (page < 1 || page > maxPage) {
            return ResponseEntity.notFound().build();
        }
        return ResponseEntity.ok(sitemapService.generateEntitySitemap(page));
    }
}
```

### SitemapScheduler

```java
package org.newsanalyzer.scheduler;

import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class SitemapScheduler {

    private final SitemapService sitemapService;

    @Scheduled(cron = "0 0 2 * * *") // Daily at 2 AM
    public void regenerateSitemaps() {
        log.info("Starting daily sitemap regeneration");

        try {
            // Clear cache to force regeneration
            sitemapService.clearCache();

            // Pre-generate sitemaps
            int pageCount = sitemapService.getPageCount();
            log.info("Generating {} sitemap pages", pageCount);

            for (int i = 1; i <= pageCount; i++) {
                sitemapService.generateEntitySitemap(i);
            }

            log.info("Sitemap regeneration completed successfully");
        } catch (Exception e) {
            log.error("Sitemap regeneration failed", e);
        }
    }
}
```

### robots.txt Update

```
# robots.txt

User-agent: *
Allow: /

# Sitemaps
Sitemap: https://newsanalyzer.org/sitemap.xml
```

### Repository Query

```java
// Add to EntityRepository.java

@Query("SELECT COUNT(e) FROM Entity e WHERE e.verified = true OR e.enrichmentStatus = 'COMPLETE'")
long countPublicEntities();

@Query("SELECT e FROM Entity e WHERE e.verified = true OR e.enrichmentStatus = 'COMPLETE' ORDER BY e.updatedAt DESC")
Page<Entity> findAllPublic(Pageable pageable);
```

### Configuration

```yaml
# application.yml
app:
  base-url: ${APP_BASE_URL:https://newsanalyzer.org}
  sitemap:
    max-urls-per-file: 50000
    regeneration-cron: "0 0 2 * * *"  # 2 AM daily
```

## Testing

### Test File Location
`backend/src/test/java/org/newsanalyzer/service/SitemapServiceTest.java`

### Testing Standards
- Use JUnit 5
- Test XML validity
- Test pagination logic
- Minimum 80% coverage

### Test Cases
```java
@Test
void generateSitemapIndex_correctFormat() {
    // Test XML structure valid
}

@Test
void generateSitemapIndex_correctPageCount() {
    // Test page count calculated correctly
}

@Test
void generateEntitySitemap_maxUrlsPerFile() {
    // Test max 50,000 URLs per file
}

@Test
void generateEntitySitemap_includesLastmod() {
    // Test lastmod present for each URL
}

@Test
void calculatePriority_enrichedEntity() {
    // Test enriched entities get higher priority
}

@Test
void controller_returnsXmlContentType() {
    // Test Content-Type is application/xml
}

@Test
void controller_invalidPage_returns404() {
    // Test invalid page number returns 404
}

@Test
void scheduler_clearsCache() {
    // Test cache cleared before regeneration
}
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-25 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_
